import { ComputedRef } from 'vue';
import { Path } from '../types/location-hook.d.js';
import { HrefsFormatter, Parser, RouterObject, SsrContext } from '../types/router.d.js';
import { Ref } from './vue-deps.js';
export declare const useRouter: () => RouterObject;
export declare const useParams: () => object & Record<"value", unknown>;
export declare const useLocation: () => (ComputedRef<string> | ((path: Path, ...args: unknown[]) => unknown))[];
export declare const useSearch: () => ComputedRef<string>;
export declare const matchRoute: (parser: Parser, route: string | RegExp, path: Path, loose?: boolean) => (string | boolean | {
    [n: number]: string;
    length: number;
    toString(): string;
    toLocaleString(): string;
    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string;
    pop(): string;
    push(...items: string[]): number;
    concat(...items: ConcatArray<string>[]): string[];
    concat(...items: (string | ConcatArray<string>)[]): string[];
    join(separator?: string): string;
    reverse(): string[];
    shift(): string;
    slice(start?: number, end?: number): string[];
    sort(compareFn?: (a: string, b: string) => number): string[];
    splice(start: number, deleteCount?: number): string[];
    splice(start: number, deleteCount: number, ...items: string[]): string[];
    unshift(...items: string[]): number;
    indexOf(searchElement: string, fromIndex?: number): number;
    lastIndexOf(searchElement: string, fromIndex?: number): number;
    every<S extends string>(predicate: (value: string, index: number, array: string[]) => value is S, thisArg?: any): this is S[];
    every(predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any): boolean;
    some(predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any): boolean;
    forEach(callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any): void;
    map<U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any): U[];
    filter<S extends string>(predicate: (value: string, index: number, array: string[]) => value is S, thisArg?: any): S[];
    filter(predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any): string[];
    reduce(callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string): string;
    reduce(callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string, initialValue: string): string;
    reduce<U>(callbackfn: (previousValue: U, currentValue: string, currentIndex: number, array: string[]) => U, initialValue: U): U;
    reduceRight(callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string): string;
    reduceRight(callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string, initialValue: string): string;
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: string, currentIndex: number, array: string[]) => U, initialValue: U): U;
    find<S extends string>(predicate: (value: string, index: number, obj: string[]) => value is S, thisArg?: any): S;
    find(predicate: (value: string, index: number, obj: string[]) => unknown, thisArg?: any): string;
    findIndex(predicate: (value: string, index: number, obj: string[]) => unknown, thisArg?: any): number;
    fill(value: string, start?: number, end?: number): string[];
    copyWithin(target: number, start: number, end?: number): string[];
    entries(): ArrayIterator<[number, string]>;
    keys(): ArrayIterator<number>;
    values(): ArrayIterator<string>;
    includes(searchElement: string, fromIndex?: number): boolean;
    flatMap<U, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U | readonly U[], thisArg?: This): U[];
    flat<A, D extends number = 1>(this: A, depth?: D): FlatArray<A, D>[];
    [Symbol.iterator](): ArrayIterator<string>;
    [Symbol.unscopables]: {
        [x: number]: boolean;
        length?: boolean;
        toString?: boolean;
        toLocaleString?: boolean;
        pop?: boolean;
        push?: boolean;
        concat?: boolean;
        join?: boolean;
        reverse?: boolean;
        shift?: boolean;
        slice?: boolean;
        sort?: boolean;
        splice?: boolean;
        unshift?: boolean;
        indexOf?: boolean;
        lastIndexOf?: boolean;
        every?: boolean;
        some?: boolean;
        forEach?: boolean;
        map?: boolean;
        filter?: boolean;
        reduce?: boolean;
        reduceRight?: boolean;
        find?: boolean;
        findIndex?: boolean;
        fill?: boolean;
        copyWithin?: boolean;
        entries?: boolean;
        keys?: boolean;
        values?: boolean;
        includes?: boolean;
        flatMap?: boolean;
        flat?: boolean;
        [Symbol.iterator]?: boolean;
        readonly [Symbol.unscopables]?: boolean;
    };
})[];
export declare const useRoute: (pattern: string | RegExp) => Ref<string | boolean | {
    [x: number]: string;
    length: number;
    toString: () => string;
    toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string;
    };
    pop: () => string;
    push: (...items: string[]) => number;
    concat: {
        (...items: ConcatArray<string>[]): string[];
        (...items: (string | ConcatArray<string>)[]): string[];
    };
    join: (separator?: string) => string;
    reverse: () => string[];
    shift: () => string;
    slice: (start?: number, end?: number) => string[];
    sort: (compareFn?: (a: string, b: string) => number) => string[];
    splice: {
        (start: number, deleteCount?: number): string[];
        (start: number, deleteCount: number, ...items: string[]): string[];
    };
    unshift: (...items: string[]) => number;
    indexOf: (searchElement: string, fromIndex?: number) => number;
    lastIndexOf: (searchElement: string, fromIndex?: number) => number;
    every: {
        <S extends string>(predicate: (value: string, index: number, array: string[]) => value is S, thisArg?: any): this is S[];
        (predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any): boolean;
    };
    some: (predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any) => boolean;
    forEach: (callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any) => void;
    map: <U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any) => U[];
    filter: {
        <S extends string>(predicate: (value: string, index: number, array: string[]) => value is S, thisArg?: any): S[];
        (predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any): string[];
    };
    reduce: {
        (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string): string;
        (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string, initialValue: string): string;
        <U>(callbackfn: (previousValue: U, currentValue: string, currentIndex: number, array: string[]) => U, initialValue: U): U;
    };
    reduceRight: {
        (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string): string;
        (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string, initialValue: string): string;
        <U>(callbackfn: (previousValue: U, currentValue: string, currentIndex: number, array: string[]) => U, initialValue: U): U;
    };
    find: {
        <S extends string>(predicate: (value: string, index: number, obj: string[]) => value is S, thisArg?: any): S;
        (predicate: (value: string, index: number, obj: string[]) => unknown, thisArg?: any): string;
    };
    findIndex: (predicate: (value: string, index: number, obj: string[]) => unknown, thisArg?: any) => number;
    fill: (value: string, start?: number, end?: number) => string[];
    copyWithin: (target: number, start: number, end?: number) => string[];
    entries: () => ArrayIterator<[number, string]>;
    keys: () => ArrayIterator<number>;
    values: () => ArrayIterator<string>;
    includes: (searchElement: string, fromIndex?: number) => boolean;
    flatMap: <U, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U | readonly U[], thisArg?: This) => U[];
    flat: <A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[];
    [Symbol.iterator]: () => ArrayIterator<string>;
    [Symbol.unscopables]: {
        [x: number]: boolean;
        length?: boolean;
        toString?: boolean;
        toLocaleString?: boolean;
        pop?: boolean;
        push?: boolean;
        concat?: boolean;
        join?: boolean;
        reverse?: boolean;
        shift?: boolean;
        slice?: boolean;
        sort?: boolean;
        splice?: boolean;
        unshift?: boolean;
        indexOf?: boolean;
        lastIndexOf?: boolean;
        every?: boolean;
        some?: boolean;
        forEach?: boolean;
        map?: boolean;
        filter?: boolean;
        reduce?: boolean;
        reduceRight?: boolean;
        find?: boolean;
        findIndex?: boolean;
        fill?: boolean;
        copyWithin?: boolean;
        entries?: boolean;
        keys?: boolean;
        values?: boolean;
        includes?: boolean;
        flatMap?: boolean;
        flat?: boolean;
        [Symbol.iterator]?: boolean;
        readonly [Symbol.unscopables]?: boolean;
    };
}, string | boolean | {
    [n: number]: string;
    length: number;
    toString(): string;
    toLocaleString(): string;
    toLocaleString(locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string;
    pop(): string;
    push(...items: string[]): number;
    concat(...items: ConcatArray<string>[]): string[];
    concat(...items: (string | ConcatArray<string>)[]): string[];
    join(separator?: string): string;
    reverse(): string[];
    shift(): string;
    slice(start?: number, end?: number): string[];
    sort(compareFn?: (a: string, b: string) => number): string[];
    splice(start: number, deleteCount?: number): string[];
    splice(start: number, deleteCount: number, ...items: string[]): string[];
    unshift(...items: string[]): number;
    indexOf(searchElement: string, fromIndex?: number): number;
    lastIndexOf(searchElement: string, fromIndex?: number): number;
    every<S extends string>(predicate: (value: string, index: number, array: string[]) => value is S, thisArg?: any): this is S[];
    every(predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any): boolean;
    some(predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any): boolean;
    forEach(callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any): void;
    map<U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any): U[];
    filter<S extends string>(predicate: (value: string, index: number, array: string[]) => value is S, thisArg?: any): S[];
    filter(predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any): string[];
    reduce(callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string): string;
    reduce(callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string, initialValue: string): string;
    reduce<U>(callbackfn: (previousValue: U, currentValue: string, currentIndex: number, array: string[]) => U, initialValue: U): U;
    reduceRight(callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string): string;
    reduceRight(callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string, initialValue: string): string;
    reduceRight<U>(callbackfn: (previousValue: U, currentValue: string, currentIndex: number, array: string[]) => U, initialValue: U): U;
    find<S extends string>(predicate: (value: string, index: number, obj: string[]) => value is S, thisArg?: any): S;
    find(predicate: (value: string, index: number, obj: string[]) => unknown, thisArg?: any): string;
    findIndex(predicate: (value: string, index: number, obj: string[]) => unknown, thisArg?: any): number;
    fill(value: string, start?: number, end?: number): string[];
    copyWithin(target: number, start: number, end?: number): string[];
    entries(): ArrayIterator<[number, string]>;
    keys(): ArrayIterator<number>;
    values(): ArrayIterator<string>;
    includes(searchElement: string, fromIndex?: number): boolean;
    flatMap<U, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U | readonly U[], thisArg?: This): U[];
    flat<A, D extends number = 1>(this: A, depth?: D): FlatArray<A, D>[];
    [Symbol.iterator](): ArrayIterator<string>;
    [Symbol.unscopables]: {
        [x: number]: boolean;
        length?: boolean;
        toString?: boolean;
        toLocaleString?: boolean;
        pop?: boolean;
        push?: boolean;
        concat?: boolean;
        join?: boolean;
        reverse?: boolean;
        shift?: boolean;
        slice?: boolean;
        sort?: boolean;
        splice?: boolean;
        unshift?: boolean;
        indexOf?: boolean;
        lastIndexOf?: boolean;
        every?: boolean;
        some?: boolean;
        forEach?: boolean;
        map?: boolean;
        filter?: boolean;
        reduce?: boolean;
        reduceRight?: boolean;
        find?: boolean;
        findIndex?: boolean;
        fill?: boolean;
        copyWithin?: boolean;
        entries?: boolean;
        keys?: boolean;
        values?: boolean;
        includes?: boolean;
        flatMap?: boolean;
        flat?: boolean;
        [Symbol.iterator]?: boolean;
        readonly [Symbol.unscopables]?: boolean;
    };
} | {
    [x: number]: string;
    length: number;
    toString: () => string;
    toLocaleString: {
        (): string;
        (locales: string | string[], options?: Intl.NumberFormatOptions & Intl.DateTimeFormatOptions): string;
    };
    pop: () => string;
    push: (...items: string[]) => number;
    concat: {
        (...items: ConcatArray<string>[]): string[];
        (...items: (string | ConcatArray<string>)[]): string[];
    };
    join: (separator?: string) => string;
    reverse: () => string[];
    shift: () => string;
    slice: (start?: number, end?: number) => string[];
    sort: (compareFn?: (a: string, b: string) => number) => string[];
    splice: {
        (start: number, deleteCount?: number): string[];
        (start: number, deleteCount: number, ...items: string[]): string[];
    };
    unshift: (...items: string[]) => number;
    indexOf: (searchElement: string, fromIndex?: number) => number;
    lastIndexOf: (searchElement: string, fromIndex?: number) => number;
    every: {
        <S extends string>(predicate: (value: string, index: number, array: string[]) => value is S, thisArg?: any): this is S[];
        (predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any): boolean;
    };
    some: (predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any) => boolean;
    forEach: (callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any) => void;
    map: <U>(callbackfn: (value: string, index: number, array: string[]) => U, thisArg?: any) => U[];
    filter: {
        <S extends string>(predicate: (value: string, index: number, array: string[]) => value is S, thisArg?: any): S[];
        (predicate: (value: string, index: number, array: string[]) => unknown, thisArg?: any): string[];
    };
    reduce: {
        (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string): string;
        (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string, initialValue: string): string;
        <U>(callbackfn: (previousValue: U, currentValue: string, currentIndex: number, array: string[]) => U, initialValue: U): U;
    };
    reduceRight: {
        (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string): string;
        (callbackfn: (previousValue: string, currentValue: string, currentIndex: number, array: string[]) => string, initialValue: string): string;
        <U>(callbackfn: (previousValue: U, currentValue: string, currentIndex: number, array: string[]) => U, initialValue: U): U;
    };
    find: {
        <S extends string>(predicate: (value: string, index: number, obj: string[]) => value is S, thisArg?: any): S;
        (predicate: (value: string, index: number, obj: string[]) => unknown, thisArg?: any): string;
    };
    findIndex: (predicate: (value: string, index: number, obj: string[]) => unknown, thisArg?: any) => number;
    fill: (value: string, start?: number, end?: number) => string[];
    copyWithin: (target: number, start: number, end?: number) => string[];
    entries: () => ArrayIterator<[number, string]>;
    keys: () => ArrayIterator<number>;
    values: () => ArrayIterator<string>;
    includes: (searchElement: string, fromIndex?: number) => boolean;
    flatMap: <U, This = undefined>(callback: (this: This, value: string, index: number, array: string[]) => U | readonly U[], thisArg?: This) => U[];
    flat: <A, D extends number = 1>(this: A, depth?: D) => FlatArray<A, D>[];
    [Symbol.iterator]: () => ArrayIterator<string>;
    [Symbol.unscopables]: {
        [x: number]: boolean;
        length?: boolean;
        toString?: boolean;
        toLocaleString?: boolean;
        pop?: boolean;
        push?: boolean;
        concat?: boolean;
        join?: boolean;
        reverse?: boolean;
        shift?: boolean;
        slice?: boolean;
        sort?: boolean;
        splice?: boolean;
        unshift?: boolean;
        indexOf?: boolean;
        lastIndexOf?: boolean;
        every?: boolean;
        some?: boolean;
        forEach?: boolean;
        map?: boolean;
        filter?: boolean;
        reduce?: boolean;
        reduceRight?: boolean;
        find?: boolean;
        findIndex?: boolean;
        fill?: boolean;
        copyWithin?: boolean;
        entries?: boolean;
        keys?: boolean;
        values?: boolean;
        includes?: boolean;
        flatMap?: boolean;
        flat?: boolean;
        [Symbol.iterator]?: boolean;
        readonly [Symbol.unscopables]?: boolean;
    };
}>[];
type RouterProps = {
    hook?: RouterObject['hook'];
    base?: Path;
    parser?: Parser;
    ssrPath?: Path;
    ssrSearch?: Path;
    ssrContext?: SsrContext;
    hrefs?: HrefsFormatter;
};
type SetupContext = {
    slots: {
        default?: () => unknown;
    };
};
export declare const Router: {
    name: string;
    props: string[];
    setup(props: RouterProps, { slots }: SetupContext): () => unknown;
};
export declare function useSearchParams(): (ComputedRef<URLSearchParams> | ((nextInit: URLSearchParams | Record<string, string> | ((params: URLSearchParams) => URLSearchParams), options?: {
    replace?: boolean;
    state?: unknown;
}) => void))[];
export declare const Route: {
    name: string;
    props: string[];
    setup(props: any, { slots }: {
        slots: any;
    }): () => any;
};
type LinkProps = {
    href?: string;
    to?: string;
    onClick?: (event: MouseEvent) => void;
    asChild?: boolean;
    classFn?: (isActive: boolean) => string;
    className?: string;
    replace?: boolean;
};
export declare const Link: {
    name: string;
    props: string[];
    inheritAttrs: boolean;
    setup(props: LinkProps, { slots, attrs }: SetupContext & {
        attrs?: Record<string, unknown>;
    }): () => import('vue').VNode<import('vue').RendererNode, import('vue').RendererElement, {
        [key: string]: any;
    }>;
};
type SwitchProps = {
    location?: Path;
};
export declare const Switch: {
    name: string;
    props: string[];
    setup(props: SwitchProps, { slots }: SetupContext): () => import('vue').VNode<import('vue').RendererNode, import('vue').RendererElement, {
        [key: string]: any;
    }>;
};
type RedirectProps = {
    to?: Path;
    href?: Path;
    replace?: boolean;
    state?: unknown;
};
export declare const Redirect: {
    name: string;
    setup(props: RedirectProps): () => any;
};
export {};
